//-----------------------------------//

// Codes dâ€™erreur :

//-----------------------------------//
// Codes dâ€™erreur bash standards :
// 0	Tout va bien (succÃ¨s)
// 1	Erreur gÃ©nÃ©rale / erreur d'exÃ©cution
// 2	Mauvais usage d'une commande (ex: syntaxe)
// 126	Commande trouvÃ©e mais non exÃ©cutable
// 127	Commande introuvable
// 130	Quit via Ctrl+C
// 131	Quit via Ctrl+(\)

// Codes personnels qui n'interfÃ¨rent pas avec bash :
// 99 Internal error: NULL input to expand_env_variables
// 98
// 97




//-----------------------------------//

// PATH invisible (Environnement) :

//-----------------------------------//
// bash ne "cache" pas vraiment le PATH â€” mais il le reconstruit dynamiquement dans certains cas.

// Ce qui se passe rÃ©ellement :
// Quand tu fais :

// bash
// Copier
// Modifier
// env -i bash --posix
// Tu lances bash avec un environnement vide, sauf les variables que tu ajoutes manuellement (ici aucune).

// Donc normalement :

// $PATH nâ€™est pas dÃ©fini dans env

// Mais echo $PATH affiche quand mÃªme quelque choseâ€¦ ğŸ˜®

// ğŸ§© Alors d'oÃ¹ vient ce $PATH ?
// ğŸ‘‰ Câ€™est bash lui-mÃªme qui :

// DÃ©finit une valeur par dÃ©faut de PATH en interne,
// sans la mettre dans env tant qu'elle nâ€™est pas utilisÃ©e dans un exec ou exportÃ©e.




//-----------------------------------//

// Bash expansion :

//-----------------------------------//
// sans quote â†’ expansion autorisÃ©e

// en quote simple â†’ expansion interdite

// en quote double â†’ expansion partielle autorisÃ©e




//-----------------------------------//

// Que fait bash si un malloc Ã©choue :

//-----------------------------------//
// Que faire en dÃ©but de minishell, si un malloc Ã©choue (et quâ€™on nâ€™a pas encore forkÃ©) ?
// âœ… Tu dois gÃ©rer lâ€™erreur proprement, afficher un message clair Ã  lâ€™utilisateur, et quitter le shell sans crash.

// ğŸ” Dans un vrai Bash ?
// Quand un Ã©chec critique se produit avant lâ€™exÃ©cution de la commande (ex: mÃ©moire insuffisante pour parser ou prÃ©parer la commande), 
Bash nâ€™exÃ©cute rien, il peut afficher une erreur, puis redonne la main Ã  lâ€™utilisateur.
// Bash ne travail pas avec un environement instable.

// Mais Bash Ã©tant ultra robuste, ces erreurs sont rares.

// âœ… Que faire dans ces cas-lÃ  ?
// Afficher une erreur explicite sur stderr

// LibÃ©rer ce qui est dÃ©jÃ  allouÃ©

// Quitter proprement le shell




//-----------------------------------//

// Ordre des opÃ©rations de Bash :

//-----------------------------------//
// ğŸ”„ Ordre des opÃ©rations de Bash (simplifiÃ©)
// Quand tu tapes une commande, Bash suit plusieurs Ã©tapes dans un ordre trÃ¨s prÃ©cis, notamment :

// Tokenization (lexing) â†’ sÃ©paration de la commande en segments (mots, opÃ©rateursâ€¦).

// Expansion (ordre prÃ©cis ci-dessous ğŸ‘‡).

// Syntax checking.

// Redirections, pipes, etc.

// Execution.

// ğŸ” Ã‰tapes internes Ã  l'expansion (ordre important)
// Dâ€™aprÃ¨s la spec POSIX et le comportement observÃ© de Bash, voici l'ordre des expansions :

// Brace expansion (ex: {a,b} â†’ a b) â†’ (rarement implÃ©mentÃ© sauf si demandÃ©).

// Tilde expansion (ex: ~ â†’ /home/user)

// Parameter expansion â†’ câ€™est ici que $USER, $?, etc. sont gÃ©rÃ©s âœ…

// Command substitution (ex: `whoami` ou $(whoami))

// Arithmetic expansion (ex: $((1 + 2)))

// Word splitting (en fonction de IFS)

// Pathname expansion (wildcards/globbing: *, ?, etc.)