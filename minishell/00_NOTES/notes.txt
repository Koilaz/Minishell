//-----------------------------------//
// Notes perso :
//-----------------------------------//

signal(SIGINT, sigint_handler); // gÃ©rer CTRL+C
signal(SIGQUIT, SIG_IGN);       // ignorer CTRL+







//-----------------------------------//
// Vieux code au cas ou :
//-----------------------------------//


// void    reassign_segment_list_index(t_segment *segment_list)
// {
//     int i;

//     i = 0;
//     while (segment_list != NULL)
//     {
//         segment_list->index = i;
//         i++;
//         segment_list = segment_list->next;
//     }
// }





// t_word_fragments *split_word_into_fragments(const char *str, int *chars_read, int *are_quotes_closed)
// {
//     t_word_fragments *fragment_list;
//     t_word_fragments *fragment;
//     char *fragment_str;
//     int i;
//     int start;
//     int len;
//     t_quote_type quote_type;

//     i = 0;
//     fragment_list = NULL;
//     while (str[i] != '\0' && is_separator(str[i]) == 0)
//     {
//         start = i;
//         len = 0;
//         quote_type = QUOTE_NONE;
//         if (str[i] == '\'' || str[i] == '\"')
//         {
//             if (str[i] == '\'')
//                 quote_type = QUOTE_SINGLE;
//             else
//                 quote_type = QUOTE_DOUBLE;
//             i++;
//             start = i;
//             while (str[i] != '\0' && ((quote_type == QUOTE_SINGLE && str[i] != '\'') ||
//                               (quote_type == QUOTE_DOUBLE && str[i] != '\"')))
//                 i++;
//             if (str[i] == '\0')
//             {
//                 *are_quotes_closed = -1;
//                 free_word_fragments(fragment_list);
//                 fragment_list = NULL;
//                 break;
//             }
//             len = i - start;
//             i++;
//         }
//         else
//         {
//             while (str[i] != '\0' && is_separator(str[i]) == 0 && str[i] != '\'' && str[i] != '\"')
//                 i++;
//             len = i - start;
//         }
//         fragment_str = ft_strndup(str + start, len);
//         if (fragment_str == NULL)
//         {
//             free_word_fragments(fragment_list);
//             return (NULL);
//         }
//         fragment = create_fragment(fragment_str, quote_type);
//         if (fragment == NULL)
//         {
//             free(fragment_str);
// 	        free_word_fragments(fragment_list);
// 	        return (NULL);
//         }
//         fragment_add_back(&fragment_list, fragment);
//     }
//     *chars_read = i;
//     return (fragment_list);
// }









//-----------------------------------//

// Codes dâ€™erreur :

//-----------------------------------//
// Codes dâ€™erreur bash standards :
// 0	Tout va bien (succÃ¨s)
// 1	Erreur gÃ©nÃ©rale / erreur d'exÃ©cution
// 2	Mauvais usage d'une commande (ex: syntaxe)
// 126	Commande trouvÃ©e mais non exÃ©cutable
// 127	Commande introuvable
// 130	Quit via Ctrl+C
// 131	Quit via Ctrl+(\)

// Codes personnels qui n'interfÃ¨rent pas avec bash :
// 99 Internal error: NULL input to expand_env_variables
// 98
// 97




//-----------------------------------//

// PATH invisible (Environnement) :

//-----------------------------------//
// bash ne "cache" pas vraiment le PATH â€” mais il le reconstruit dynamiquement dans certains cas.

// Ce qui se passe rÃ©ellement :
// Quand tu fais :

// bash
// Copier
// Modifier
// env -i bash --posix
// Tu lances bash avec un environnement vide, sauf les variables que tu ajoutes manuellement (ici aucune).

// Donc normalement :

// $PATH nâ€™est pas dÃ©fini dans env

// Mais echo $PATH affiche quand mÃªme quelque choseâ€¦ ğŸ˜®

// ğŸ§© Alors d'oÃ¹ vient ce $PATH ?
// ğŸ‘‰ Câ€™est bash lui-mÃªme qui :

// DÃ©finit une valeur par dÃ©faut de PATH en interne,
// sans la mettre dans env tant qu'elle nâ€™est pas utilisÃ©e dans un exec ou exportÃ©e.




//-----------------------------------//

// Bash expansion :

//-----------------------------------//
// sans quote â†’ expansion autorisÃ©e

// en quote simple â†’ expansion interdite

// en quote double â†’ expansion partielle autorisÃ©e




//-----------------------------------//

// Que fait bash si un malloc Ã©choue :

//-----------------------------------//
// Que faire en dÃ©but de minishell, si un malloc Ã©choue (et quâ€™on nâ€™a pas encore forkÃ©) ?
// âœ… Tu dois gÃ©rer lâ€™erreur proprement, afficher un message clair Ã  lâ€™utilisateur, et quitter le shell sans crash.

// ğŸ” Dans un vrai Bash ?
// Quand un Ã©chec critique se produit avant lâ€™exÃ©cution de la commande (ex: mÃ©moire insuffisante pour parser ou prÃ©parer la commande), 
Bash nâ€™exÃ©cute rien, il peut afficher une erreur, puis redonne la main Ã  lâ€™utilisateur.
// Bash ne travail pas avec un environement instable.

// Mais Bash Ã©tant ultra robuste, ces erreurs sont rares.

// âœ… Que faire dans ces cas-lÃ  ?
// Afficher une erreur explicite sur stderr

// LibÃ©rer ce qui est dÃ©jÃ  allouÃ©

// Quitter proprement le shell




//-----------------------------------//

// Ordre des opÃ©rations de Bash :

//-----------------------------------//
// ğŸ”„ Ordre des opÃ©rations de Bash (simplifiÃ©)
// Quand tu tapes une commande, Bash suit plusieurs Ã©tapes dans un ordre trÃ¨s prÃ©cis, notamment :

// Tokenization (lexing) â†’ sÃ©paration de la commande en segments (mots, opÃ©rateursâ€¦).

// Expansion (ordre prÃ©cis ci-dessous ğŸ‘‡).

// Syntax checking.

// Redirections, pipes, etc.

// Execution.

// ğŸ” Ã‰tapes internes Ã  l'expansion (ordre important)
// Dâ€™aprÃ¨s la spec POSIX et le comportement observÃ© de Bash, voici l'ordre des expansions :

// Brace expansion (ex: {a,b} â†’ a b) â†’ (rarement implÃ©mentÃ© sauf si demandÃ©).

// Tilde expansion (ex: ~ â†’ /home/user)

// Parameter expansion â†’ câ€™est ici que $USER, $?, etc. sont gÃ©rÃ©s âœ…

// Command substitution (ex: `whoami` ou $(whoami))

// Arithmetic expansion (ex: $((1 + 2)))

// Word splitting (en fonction de IFS)

// Pathname expansion (wildcards/globbing: *, ?, etc.)